事务消息是 RocketMQ 的高级特性之一，本文为您介绍 RocketMQ 事务消息的应用场景、功能原理、实战例子、源码解析。

![](https://itcourage.cn/pics/rocketmq/rocketmqcategory.png?a=48)

# 1 应用场景

![](https://itcourage.cn/pics/rocketmq/transactionchangjing.png?c=14)

以电商交易场景为例，**用户支付订单**这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。

当前业务的处理分支包括：

- 主分支订单系统状态更新：由未支付变更为支付成功。
- 物流系统状态新增：新增待发货物流记录，创建订单物流记录。
- 积分系统状态变更：变更用户积分，更新用户积分表。
- 购物车系统状态变更：清空购物车，更新用户购物车记录。

**1、传统XA事务方案：性能不足**

为了保证上述四个分支的执行结果一致性，典型方案是基于 XA 协议的分布式事务系统来实现。将四个调用分支封装成包含四个独立事务分支的大事务。基于 XA 分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。

**2、基于普通消息方案：一致性保障困难**

![](https://itcourage.cn/pics/rocketmq/transactionnormalmessage.png?c=1)

该方案中消息下游分支和订单系统变更的主分支很容易出现不一致的现象，例如：

- 消息发送成功，订单没有执行成功，需要回滚整个事务。
- 订单执行成功，消息没有发送成功，需要额外补偿才能发现不一致。
- 消息发送超时未知，此时无法判断需要回滚订单还是提交订单变更。

**3、基于 RocketMQ 分布式事务消息：支持最终一致性**

上述普通消息方案中，普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。

而基于 RocketMQ 实现的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。

# 2 功能原理

事务消息是 RocketMQ 提供的一种高级消息类型，支持在分布式场景下**保障消息生产和本地事务的最终一致性**。

交互流程如下图所示。

![](https://itcourage.cn/pics/rocketmq/transactionyuanli.png)

1. 生产者将消息发送至 Broker 。
2. Broker 将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为"**暂不能投递**"，这种状态下的消息即为**半事务消息**。
3. 生产者开始**执行本地事务逻辑**。
4. 生产者根据本地事务执行结果向服务端**提交二次确认结果**（ Commit 或是 Rollback ），服务端收到确认结果后处理逻辑如下：
   - 二次确认结果为 Commit ：服务端将半事务消息标记为可投递，并投递给消费者。
   - 二次确认结果为 Rollback ：服务端将回滚事务，不会将半事务消息投递给消费者。
5. 在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为 Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起**消息回查**。
6. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
7. 生产者根据检查到的本地事务的最终状态**再次提交二次确认**，服务端仍按照步骤4对半事务消息进行处理。

事务消息回查步骤如下：

1. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
2. 生产者根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。

# 3 实战例子



















# 4 源码解析





















# 5 总结

